/**
 * Bitbucket API
 * Code against the Bitbucket API to automate simple tasks, embed Bitbucket data into your own site, build mobile or desktop apps, or even add custom UI add-ons into Bitbucket itself using the Connect framework.
 *
 * The version of the OpenAPI document: 2.0
 * Contact: support@bitbucket.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');

/* tslint:disable:no-unused-locals */
import { Component } from '../model/component';
import { Issue } from '../model/issue';
import { IssueChange } from '../model/issueChange';
import { IssueComment } from '../model/issueComment';
import { Milestone } from '../model/milestone';
import { PaginatedComponents } from '../model/paginatedComponents';
import { PaginatedIssueAttachments } from '../model/paginatedIssueAttachments';
import { PaginatedIssueComments } from '../model/paginatedIssueComments';
import { PaginatedIssues } from '../model/paginatedIssues';
import { PaginatedLogEntries } from '../model/paginatedLogEntries';
import { PaginatedMilestones } from '../model/paginatedMilestones';
import { PaginatedVersions } from '../model/paginatedVersions';
import { Version } from '../model/version';

import { ObjectSerializer, Authentication, VoidAuth } from '../model/models';
import { ApiKeyAuth } from '../model/models';
import { HttpBasicAuth } from '../model/models';
import { OAuth } from '../model/models';

let defaultBasePath = 'https://api.bitbucket.org/2.0';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum IssueTrackerApiApiKeys {
    api_key,
}

export class IssueTrackerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'api_key': new ApiKeyAuth('header', 'Authorization'),
        'basic': new HttpBasicAuth(),
        'oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: IssueTrackerApiApiKeys, value: string) {
        (this.authentications as any)[IssueTrackerApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basic.username = username;
    }

    set password(password: string) {
        this.authentications.basic.password = password;
    }

    set accessToken(token: string) {
        this.authentications.oauth2.accessToken = token;
    }

    /**
     * Returns the specified issue tracker component object.
     * @param username This can either be the username or the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. An account is either a team or user. 
     * @param componentId The component\&#39;s id
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    public async repositoriesUsernameRepoSlugComponentsComponentIdGet (username: string, componentId: number, repoSlug: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: Component;  }> {
        const localVarPath = this.basePath + '/repositories/{username}/{repo_slug}/components/{component_id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'component_id' + '}', encodeURIComponent(String(componentId)))
            .replace('{' + 'repo_slug' + '}', encodeURIComponent(String(repoSlug)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling repositoriesUsernameRepoSlugComponentsComponentIdGet.');
        }

        // verify required parameter 'componentId' is not null or undefined
        if (componentId === null || componentId === undefined) {
            throw new Error('Required parameter componentId was null or undefined when calling repositoriesUsernameRepoSlugComponentsComponentIdGet.');
        }

        // verify required parameter 'repoSlug' is not null or undefined
        if (repoSlug === null || repoSlug === undefined) {
            throw new Error('Required parameter repoSlug was null or undefined when calling repositoriesUsernameRepoSlugComponentsComponentIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.basic.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: Component;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Component");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the components that have been defined in the issue tracker.  This resource is only available on repositories that have the issue tracker enabled.
     * @param username This can either be the username or the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. An account is either a team or user. 
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    public async repositoriesUsernameRepoSlugComponentsGet (username: string, repoSlug: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: PaginatedComponents;  }> {
        const localVarPath = this.basePath + '/repositories/{username}/{repo_slug}/components'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'repo_slug' + '}', encodeURIComponent(String(repoSlug)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling repositoriesUsernameRepoSlugComponentsGet.');
        }

        // verify required parameter 'repoSlug' is not null or undefined
        if (repoSlug === null || repoSlug === undefined) {
            throw new Error('Required parameter repoSlug was null or undefined when calling repositoriesUsernameRepoSlugComponentsGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.basic.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: PaginatedComponents;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "PaginatedComponents");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the issues in the issue tracker.
     * @param username This can either be the username or the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. An account is either a team or user. 
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    public async repositoriesUsernameRepoSlugIssuesGet (username: string, repoSlug: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: PaginatedIssues;  }> {
        const localVarPath = this.basePath + '/repositories/{username}/{repo_slug}/issues'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'repo_slug' + '}', encodeURIComponent(String(repoSlug)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling repositoriesUsernameRepoSlugIssuesGet.');
        }

        // verify required parameter 'repoSlug' is not null or undefined
        if (repoSlug === null || repoSlug === undefined) {
            throw new Error('Required parameter repoSlug was null or undefined when calling repositoriesUsernameRepoSlugIssuesGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.basic.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: PaginatedIssues;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "PaginatedIssues");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns all attachments for this issue.  This returns the files\' meta data. This does not return the files\' actual contents.  The files are always ordered by their upload date.
     * @param username 
     * @param repoSlug 
     * @param issueId The issue\&#39;s id
     */
    public async repositoriesUsernameRepoSlugIssuesIssueIdAttachmentsGet (username: string, repoSlug: string, issueId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: PaginatedIssueAttachments;  }> {
        const localVarPath = this.basePath + '/repositories/{username}/{repo_slug}/issues/{issue_id}/attachments'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'repo_slug' + '}', encodeURIComponent(String(repoSlug)))
            .replace('{' + 'issue_id' + '}', encodeURIComponent(String(issueId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdAttachmentsGet.');
        }

        // verify required parameter 'repoSlug' is not null or undefined
        if (repoSlug === null || repoSlug === undefined) {
            throw new Error('Required parameter repoSlug was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdAttachmentsGet.');
        }

        // verify required parameter 'issueId' is not null or undefined
        if (issueId === null || issueId === undefined) {
            throw new Error('Required parameter issueId was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdAttachmentsGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.basic.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: PaginatedIssueAttachments;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "PaginatedIssueAttachments");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            });
        });
    }
    /**
     * Deletes an attachment.
     * @param username 
     * @param path 
     * @param issueId 
     * @param repoSlug 
     */
    public async repositoriesUsernameRepoSlugIssuesIssueIdAttachmentsPathDelete (username: string, path: string, issueId: string, repoSlug: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/repositories/{username}/{repo_slug}/issues/{issue_id}/attachments/{path}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'path' + '}', encodeURIComponent(String(path)))
            .replace('{' + 'issue_id' + '}', encodeURIComponent(String(issueId)))
            .replace('{' + 'repo_slug' + '}', encodeURIComponent(String(repoSlug)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdAttachmentsPathDelete.');
        }

        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdAttachmentsPathDelete.');
        }

        // verify required parameter 'issueId' is not null or undefined
        if (issueId === null || issueId === undefined) {
            throw new Error('Required parameter issueId was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdAttachmentsPathDelete.');
        }

        // verify required parameter 'repoSlug' is not null or undefined
        if (repoSlug === null || repoSlug === undefined) {
            throw new Error('Required parameter repoSlug was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdAttachmentsPathDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.basic.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the contents of the specified file attachment.  Note that this endpoint does not return a JSON response, but instead returns a redirect pointing to the actual file that in turn will return the raw contents.  The redirect URL contains a one-time token that has a limited lifetime. As a result, the link should not be persisted, stored, or shared.
     * @param username 
     * @param path 
     * @param issueId 
     * @param repoSlug 
     */
    public async repositoriesUsernameRepoSlugIssuesIssueIdAttachmentsPathGet (username: string, path: string, issueId: string, repoSlug: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/repositories/{username}/{repo_slug}/issues/{issue_id}/attachments/{path}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'path' + '}', encodeURIComponent(String(path)))
            .replace('{' + 'issue_id' + '}', encodeURIComponent(String(issueId)))
            .replace('{' + 'repo_slug' + '}', encodeURIComponent(String(repoSlug)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdAttachmentsPathGet.');
        }

        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdAttachmentsPathGet.');
        }

        // verify required parameter 'issueId' is not null or undefined
        if (issueId === null || issueId === undefined) {
            throw new Error('Required parameter issueId was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdAttachmentsPathGet.');
        }

        // verify required parameter 'repoSlug' is not null or undefined
        if (repoSlug === null || repoSlug === undefined) {
            throw new Error('Required parameter repoSlug was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdAttachmentsPathGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.basic.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            });
        });
    }
    /**
     * Upload new issue attachments.  To upload files, perform a `multipart/form-data` POST containing one or more file fields.  When a file is uploaded with the same name as an existing attachment, then the existing file will be replaced.
     * @param username 
     * @param repoSlug 
     * @param issueId The issue\&#39;s id
     */
    public async repositoriesUsernameRepoSlugIssuesIssueIdAttachmentsPost (username: string, repoSlug: string, issueId: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/repositories/{username}/{repo_slug}/issues/{issue_id}/attachments'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'repo_slug' + '}', encodeURIComponent(String(repoSlug)))
            .replace('{' + 'issue_id' + '}', encodeURIComponent(String(issueId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdAttachmentsPost.');
        }

        // verify required parameter 'repoSlug' is not null or undefined
        if (repoSlug === null || repoSlug === undefined) {
            throw new Error('Required parameter repoSlug was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdAttachmentsPost.');
        }

        // verify required parameter 'issueId' is not null or undefined
        if (issueId === null || issueId === undefined) {
            throw new Error('Required parameter issueId was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdAttachmentsPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.basic.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the specified issue change object.  This resource is only available on repositories that have the issue tracker enabled.
     * @param username This can either be the username or the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. An account is either a team or user. 
     * @param changeId The issue change id
     * @param issueId The issue id
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    public async repositoriesUsernameRepoSlugIssuesIssueIdChangesChangeIdGet (username: string, changeId: string, issueId: string, repoSlug: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: IssueChange;  }> {
        const localVarPath = this.basePath + '/repositories/{username}/{repo_slug}/issues/{issue_id}/changes/{change_id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'change_id' + '}', encodeURIComponent(String(changeId)))
            .replace('{' + 'issue_id' + '}', encodeURIComponent(String(issueId)))
            .replace('{' + 'repo_slug' + '}', encodeURIComponent(String(repoSlug)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdChangesChangeIdGet.');
        }

        // verify required parameter 'changeId' is not null or undefined
        if (changeId === null || changeId === undefined) {
            throw new Error('Required parameter changeId was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdChangesChangeIdGet.');
        }

        // verify required parameter 'issueId' is not null or undefined
        if (issueId === null || issueId === undefined) {
            throw new Error('Required parameter issueId was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdChangesChangeIdGet.');
        }

        // verify required parameter 'repoSlug' is not null or undefined
        if (repoSlug === null || repoSlug === undefined) {
            throw new Error('Required parameter repoSlug was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdChangesChangeIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.basic.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: IssueChange;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "IssueChange");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the list of all changes that have been made to the specified issue. Changes are returned in chronological order with the oldest change first.  Each time an issue is edited in the UI or through the API, an immutable change record is created under the `/issues/123/changes` endpoint. It also has a comment associated with the change.  Note that this operation is changing significantly, due to privacy changes. See the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#changes-to-the-issue-changes-api) for details.  ``` $ curl -s https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/issues/1/changes - | jq .  {   \"pagelen\": 20,   \"values\": [     {       \"changes\": {         \"priority\": {           \"new\": \"trivial\",           \"old\": \"major\"         },         \"assignee\": {           \"new\": \"\",           \"old\": \"evzijst\"         },         \"assignee_account_id\": {           \"new\": \"\",           \"old\": \"557058:c0b72ad0-1cb5-4018-9cdc-0cde8492c443\"         },         \"kind\": {           \"new\": \"enhancement\",           \"old\": \"bug\"         }       },       \"links\": {         \"self\": {           \"href\": \"https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/issues/1/changes/2\"         },         \"html\": {           \"href\": \"https://bitbucket.org/evzijst/dogslow/issues/1#comment-2\"         }       },       \"issue\": {         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/issues/1\"           }         },         \"type\": \"issue\",         \"id\": 1,         \"repository\": {           \"links\": {             \"self\": {               \"href\": \"https://api.bitbucket.org/2.0/repositories/evzijst/dogslow\"             },             \"html\": {               \"href\": \"https://bitbucket.org/evzijst/dogslow\"             },             \"avatar\": {               \"href\": \"https://bitbucket.org/evzijst/dogslow/avatar/32/\"             }           },           \"type\": \"repository\",           \"name\": \"dogslow\",           \"full_name\": \"evzijst/dogslow\",           \"uuid\": \"{988b17c6-1a47-4e70-84ee-854d5f012bf6}\"         },         \"title\": \"Updated title\"       },       \"created_on\": \"2018-03-03T00:35:28.353630+00:00\",       \"user\": {         \"username\": \"evzijst\",         \"nickname\": \"evzijst\",         \"display_name\": \"evzijst\",         \"type\": \"user\",         \"uuid\": \"{aaa7972b-38af-4fb1-802d-6e3854c95778}\",         \"links\": {           \"self\": {             \"href\": \"https://api.bitbucket.org/2.0/users/evzijst\"           },           \"html\": {             \"href\": \"https://bitbucket.org/evzijst/\"           },           \"avatar\": {             \"href\": \"https://bitbucket.org/account/evzijst/avatar/32/\"           }         }       },       \"message\": {         \"raw\": \"Removed assignee, changed kind and priority.\",         \"markup\": \"markdown\",         \"html\": \"<p>Removed assignee, changed kind and priority.</p>\",         \"type\": \"rendered\"       },       \"type\": \"issue_change\",       \"id\": 2     }   ],   \"page\": 1 } ```  Changes support [filtering and sorting](../../../meta/filtering) that can be used to search for specific changes. For instance, to see when an issue transitioned to \"resolved\":  ``` $ curl -s https://api.bitbucket.org/2.0/repositories/site/master/issues/1/changes \\    -G --data-urlencode=\'q=changes.state.new = \"resolved\"\' ```  This resource is only available on repositories that have the issue tracker enabled.  N.B.  The `changes.assignee` and `changes.assignee_account_id` fields are not a `user` object. Instead, they contain the raw `username` and `account_id` of the user. This is to protect the integrity of the audit log even after a user account gets deleted.  The `changes.assignee` field is deprecated will disappear in the future. Use `changes.assignee_account_id` instead.
     * @param username This can either be the username or the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. An account is either a team or user. 
     * @param issueId The issue id
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     * @param q  Query string to narrow down the response. See [filtering and sorting](../../../meta/filtering) for details.
     * @param sort  Name of a response property to sort results. See [filtering and sorting](../../../meta/filtering#query-sort) for details. 
     */
    public async repositoriesUsernameRepoSlugIssuesIssueIdChangesGet (username: string, issueId: string, repoSlug: string, q?: string, sort?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: PaginatedLogEntries;  }> {
        const localVarPath = this.basePath + '/repositories/{username}/{repo_slug}/issues/{issue_id}/changes'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'issue_id' + '}', encodeURIComponent(String(issueId)))
            .replace('{' + 'repo_slug' + '}', encodeURIComponent(String(repoSlug)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdChangesGet.');
        }

        // verify required parameter 'issueId' is not null or undefined
        if (issueId === null || issueId === undefined) {
            throw new Error('Required parameter issueId was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdChangesGet.');
        }

        // verify required parameter 'repoSlug' is not null or undefined
        if (repoSlug === null || repoSlug === undefined) {
            throw new Error('Required parameter repoSlug was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdChangesGet.');
        }

        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.basic.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: PaginatedLogEntries;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "PaginatedLogEntries");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            });
        });
    }
    /**
     * Makes a change to the specified issue.  For example, to change an issue\'s state and assignee, create a new change object that modifies these fields:  ``` curl https://api.bitbucket.org/2.0/site/master/issues/1234/changes \\   -s -u evzijst -X POST -H \"Content-Type: application/json\" \\   -d \'{     \"changes\": {       \"assignee_account_id\": {         \"new\": \"557058:c0b72ad0-1cb5-4018-9cdc-0cde8492c443\"       },       \"state\": {         \"new\": \'resolved\"       }     }     \"message\": {       \"raw\": \"This is now resolved.\"     }   }\' ```  The above example also includes a custom comment to go alongside the change. This comment will also be visible on the issue page in the UI.  The fields of the `changes` object are strings, not objects. This allows for immutable change log records, even after user accounts, milestones, or other objects recorded in a change entry, get renamed or deleted.  The `assignee_account_id` field stores the account id. When POSTing a new change and changing the assignee, the client should therefore use the user\'s account_id in the `changes.assignee_account_id.new` field.  This call requires authentication. Private repositories or private issue trackers require the caller to authenticate with an account that has appropriate authorization.
     * @param username This can either be the username or the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. An account is either a team or user. 
     * @param issueId The issue id
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     * @param body The new issue state change. The only required elements are &#x60;changes.[].new&#x60;. All other elements can be omitted from the body.
     */
    public async repositoriesUsernameRepoSlugIssuesIssueIdChangesPost (username: string, issueId: string, repoSlug: string, body: IssueChange, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: IssueChange;  }> {
        const localVarPath = this.basePath + '/repositories/{username}/{repo_slug}/issues/{issue_id}/changes'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'issue_id' + '}', encodeURIComponent(String(issueId)))
            .replace('{' + 'repo_slug' + '}', encodeURIComponent(String(repoSlug)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdChangesPost.');
        }

        // verify required parameter 'issueId' is not null or undefined
        if (issueId === null || issueId === undefined) {
            throw new Error('Required parameter issueId was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdChangesPost.');
        }

        // verify required parameter 'repoSlug' is not null or undefined
        if (repoSlug === null || repoSlug === undefined) {
            throw new Error('Required parameter repoSlug was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdChangesPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdChangesPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "IssueChange")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.basic.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: IssueChange;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "IssueChange");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            });
        });
    }
    /**
     * Deletes the specified comment.
     * @param commentId 
     * @param username This can either be the username or the UUID of the user, surrounded by curly-braces, for example: &#x60;{user UUID}&#x60;. 
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     * @param issueId The ID of the issue that is being queried. 
     * @param body The updated comment.
     */
    public async repositoriesUsernameRepoSlugIssuesIssueIdCommentsCommentIdDelete (commentId: string, username: string, repoSlug: string, issueId: string, body: IssueComment, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/repositories/{username}/{repo_slug}/issues/{issue_id}/comments/{comment_id}'
            .replace('{' + 'comment_id' + '}', encodeURIComponent(String(commentId)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'repo_slug' + '}', encodeURIComponent(String(repoSlug)))
            .replace('{' + 'issue_id' + '}', encodeURIComponent(String(issueId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'commentId' is not null or undefined
        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdCommentsCommentIdDelete.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdCommentsCommentIdDelete.');
        }

        // verify required parameter 'repoSlug' is not null or undefined
        if (repoSlug === null || repoSlug === undefined) {
            throw new Error('Required parameter repoSlug was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdCommentsCommentIdDelete.');
        }

        // verify required parameter 'issueId' is not null or undefined
        if (issueId === null || issueId === undefined) {
            throw new Error('Required parameter issueId was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdCommentsCommentIdDelete.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdCommentsCommentIdDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "IssueComment")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.basic.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the specified issue comment object.
     * @param commentId 
     * @param username This can either be the username or the UUID of the user, surrounded by curly-braces, for example: &#x60;{user UUID}&#x60;. 
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     * @param issueId The ID of the issue that is being queried. 
     */
    public async repositoriesUsernameRepoSlugIssuesIssueIdCommentsCommentIdGet (commentId: string, username: string, repoSlug: string, issueId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: IssueComment;  }> {
        const localVarPath = this.basePath + '/repositories/{username}/{repo_slug}/issues/{issue_id}/comments/{comment_id}'
            .replace('{' + 'comment_id' + '}', encodeURIComponent(String(commentId)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'repo_slug' + '}', encodeURIComponent(String(repoSlug)))
            .replace('{' + 'issue_id' + '}', encodeURIComponent(String(issueId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'commentId' is not null or undefined
        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdCommentsCommentIdGet.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdCommentsCommentIdGet.');
        }

        // verify required parameter 'repoSlug' is not null or undefined
        if (repoSlug === null || repoSlug === undefined) {
            throw new Error('Required parameter repoSlug was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdCommentsCommentIdGet.');
        }

        // verify required parameter 'issueId' is not null or undefined
        if (issueId === null || issueId === undefined) {
            throw new Error('Required parameter issueId was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdCommentsCommentIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.basic.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: IssueComment;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "IssueComment");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            });
        });
    }
    /**
     * Updates the content of the specified issue comment. Note that only the `content.raw` field can be modified.  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/5728901 \\   -X PUT -u evzijst \\   -H \'Content-Type: application/json\' \\   -d \'{\"content\": {\"raw\": \"Lorem ipsum.\"}\' ```
     * @param commentId 
     * @param username This can either be the username or the UUID of the user, surrounded by curly-braces, for example: &#x60;{user UUID}&#x60;. 
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     * @param issueId The ID of the issue that is being queried. 
     * @param body The updated comment.
     */
    public async repositoriesUsernameRepoSlugIssuesIssueIdCommentsCommentIdPut (commentId: string, username: string, repoSlug: string, issueId: string, body: IssueComment, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: IssueComment;  }> {
        const localVarPath = this.basePath + '/repositories/{username}/{repo_slug}/issues/{issue_id}/comments/{comment_id}'
            .replace('{' + 'comment_id' + '}', encodeURIComponent(String(commentId)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'repo_slug' + '}', encodeURIComponent(String(repoSlug)))
            .replace('{' + 'issue_id' + '}', encodeURIComponent(String(issueId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'commentId' is not null or undefined
        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdCommentsCommentIdPut.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdCommentsCommentIdPut.');
        }

        // verify required parameter 'repoSlug' is not null or undefined
        if (repoSlug === null || repoSlug === undefined) {
            throw new Error('Required parameter repoSlug was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdCommentsCommentIdPut.');
        }

        // verify required parameter 'issueId' is not null or undefined
        if (issueId === null || issueId === undefined) {
            throw new Error('Required parameter issueId was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdCommentsCommentIdPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdCommentsCommentIdPut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "IssueComment")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.basic.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: IssueComment;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "IssueComment");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns a paginated list of all comments that were made on the specified issue.  The default sorting is oldest to newest and can be overridden with the `sort` query parameter.  This endpoint also supports filtering and sorting of the results. See [filtering and sorting](../../../../../../meta/filtering) for more details.
     * @param issueId 
     * @param username This can either be the username or the UUID of the user, surrounded by curly-braces, for example: &#x60;{user UUID}&#x60;. 
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     * @param q  Query string to narrow down the response as per [filtering and sorting](../../../../../../meta/filtering).
     */
    public async repositoriesUsernameRepoSlugIssuesIssueIdCommentsGet (issueId: string, username: string, repoSlug: string, q?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: PaginatedIssueComments;  }> {
        const localVarPath = this.basePath + '/repositories/{username}/{repo_slug}/issues/{issue_id}/comments'
            .replace('{' + 'issue_id' + '}', encodeURIComponent(String(issueId)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'repo_slug' + '}', encodeURIComponent(String(repoSlug)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'issueId' is not null or undefined
        if (issueId === null || issueId === undefined) {
            throw new Error('Required parameter issueId was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdCommentsGet.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdCommentsGet.');
        }

        // verify required parameter 'repoSlug' is not null or undefined
        if (repoSlug === null || repoSlug === undefined) {
            throw new Error('Required parameter repoSlug was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdCommentsGet.');
        }

        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.basic.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: PaginatedIssueComments;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "PaginatedIssueComments");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            });
        });
    }
    /**
     * Creates a new issue comment.  ``` $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/ \\   -X POST -u evzijst \\   -H \'Content-Type: application/json\' \\   -d \'{\"content\": {\"raw\": \"Lorem ipsum.\"}}\' ```
     * @param issueId 
     * @param username This can either be the username or the UUID of the user, surrounded by curly-braces, for example: &#x60;{user UUID}&#x60;. 
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     * @param body The new issue comment object.
     */
    public async repositoriesUsernameRepoSlugIssuesIssueIdCommentsPost (issueId: string, username: string, repoSlug: string, body: IssueComment, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/repositories/{username}/{repo_slug}/issues/{issue_id}/comments'
            .replace('{' + 'issue_id' + '}', encodeURIComponent(String(issueId)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'repo_slug' + '}', encodeURIComponent(String(repoSlug)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'issueId' is not null or undefined
        if (issueId === null || issueId === undefined) {
            throw new Error('Required parameter issueId was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdCommentsPost.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdCommentsPost.');
        }

        // verify required parameter 'repoSlug' is not null or undefined
        if (repoSlug === null || repoSlug === undefined) {
            throw new Error('Required parameter repoSlug was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdCommentsPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdCommentsPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "IssueComment")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.basic.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            });
        });
    }
    /**
     * Deletes the specified issue. This requires write access to the repository.
     * @param username This can either be the username or the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. An account is either a team or user. 
     * @param issueId The issue id
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    public async repositoriesUsernameRepoSlugIssuesIssueIdDelete (username: string, issueId: string, repoSlug: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: Issue;  }> {
        const localVarPath = this.basePath + '/repositories/{username}/{repo_slug}/issues/{issue_id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'issue_id' + '}', encodeURIComponent(String(issueId)))
            .replace('{' + 'repo_slug' + '}', encodeURIComponent(String(repoSlug)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdDelete.');
        }

        // verify required parameter 'issueId' is not null or undefined
        if (issueId === null || issueId === undefined) {
            throw new Error('Required parameter issueId was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdDelete.');
        }

        // verify required parameter 'repoSlug' is not null or undefined
        if (repoSlug === null || repoSlug === undefined) {
            throw new Error('Required parameter repoSlug was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.basic.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: Issue;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Issue");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the specified issue.
     * @param username This can either be the username or the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. An account is either a team or user. 
     * @param issueId The issue id
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    public async repositoriesUsernameRepoSlugIssuesIssueIdGet (username: string, issueId: string, repoSlug: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: Issue;  }> {
        const localVarPath = this.basePath + '/repositories/{username}/{repo_slug}/issues/{issue_id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'issue_id' + '}', encodeURIComponent(String(issueId)))
            .replace('{' + 'repo_slug' + '}', encodeURIComponent(String(repoSlug)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdGet.');
        }

        // verify required parameter 'issueId' is not null or undefined
        if (issueId === null || issueId === undefined) {
            throw new Error('Required parameter issueId was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdGet.');
        }

        // verify required parameter 'repoSlug' is not null or undefined
        if (repoSlug === null || repoSlug === undefined) {
            throw new Error('Required parameter repoSlug was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.basic.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: Issue;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Issue");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            });
        });
    }
    /**
     * Modifies the issue.  ``` $ curl https://api.bitbucket.org/2.0/repostories/evzijst/dogslow/issues/123 \\   -u evzijst -s -X PUT -H \'Content-Type: application/json\' \\   -d \'{   \"title\": \"Updated title\",   \"assignee\": {     \"username\": \"evzijst\"   },   \"priority\": \"minor\",   \"version\": {     \"name\": \"1.0\"   },   \"component\": null }\' ```  This example changes the `title`, `assignee`, `priority` and the `version`. It also removes the value of the `component` from the issue by setting the field to `null`. Any field not present keeps its existing value.  Each time an issue is edited in the UI or through the API, an immutable change record is created under the `/issues/123/changes` endpoint. It also has a comment associated with the change.
     * @param username This can either be the username or the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. An account is either a team or user. 
     * @param issueId The issue id
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    public async repositoriesUsernameRepoSlugIssuesIssueIdPut (username: string, issueId: string, repoSlug: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: Issue;  }> {
        const localVarPath = this.basePath + '/repositories/{username}/{repo_slug}/issues/{issue_id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'issue_id' + '}', encodeURIComponent(String(issueId)))
            .replace('{' + 'repo_slug' + '}', encodeURIComponent(String(repoSlug)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdPut.');
        }

        // verify required parameter 'issueId' is not null or undefined
        if (issueId === null || issueId === undefined) {
            throw new Error('Required parameter issueId was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdPut.');
        }

        // verify required parameter 'repoSlug' is not null or undefined
        if (repoSlug === null || repoSlug === undefined) {
            throw new Error('Required parameter repoSlug was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdPut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.basic.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: Issue;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Issue");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            });
        });
    }
    /**
     * Retract your vote.
     * @param username This can either be the username or the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. An account is either a team or user. 
     * @param issueId The issue id
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    public async repositoriesUsernameRepoSlugIssuesIssueIdVoteDelete (username: string, issueId: string, repoSlug: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: Error;  }> {
        const localVarPath = this.basePath + '/repositories/{username}/{repo_slug}/issues/{issue_id}/vote'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'issue_id' + '}', encodeURIComponent(String(issueId)))
            .replace('{' + 'repo_slug' + '}', encodeURIComponent(String(repoSlug)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdVoteDelete.');
        }

        // verify required parameter 'issueId' is not null or undefined
        if (issueId === null || issueId === undefined) {
            throw new Error('Required parameter issueId was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdVoteDelete.');
        }

        // verify required parameter 'repoSlug' is not null or undefined
        if (repoSlug === null || repoSlug === undefined) {
            throw new Error('Required parameter repoSlug was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdVoteDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.basic.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: Error;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Error");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            });
        });
    }
    /**
     * Check whether the authenticated user has voted for this issue. A 204 status code indicates that the user has voted, while a 404 implies they haven\'t.
     * @param username This can either be the username or the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. An account is either a team or user. 
     * @param issueId The issue id
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    public async repositoriesUsernameRepoSlugIssuesIssueIdVoteGet (username: string, issueId: string, repoSlug: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: Error;  }> {
        const localVarPath = this.basePath + '/repositories/{username}/{repo_slug}/issues/{issue_id}/vote'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'issue_id' + '}', encodeURIComponent(String(issueId)))
            .replace('{' + 'repo_slug' + '}', encodeURIComponent(String(repoSlug)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdVoteGet.');
        }

        // verify required parameter 'issueId' is not null or undefined
        if (issueId === null || issueId === undefined) {
            throw new Error('Required parameter issueId was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdVoteGet.');
        }

        // verify required parameter 'repoSlug' is not null or undefined
        if (repoSlug === null || repoSlug === undefined) {
            throw new Error('Required parameter repoSlug was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdVoteGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.basic.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: Error;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Error");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            });
        });
    }
    /**
     * Vote for this issue.  To cast your vote, do an empty PUT. The 204 status code indicates that the operation was successful.
     * @param username This can either be the username or the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. An account is either a team or user. 
     * @param issueId The issue id
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    public async repositoriesUsernameRepoSlugIssuesIssueIdVotePut (username: string, issueId: string, repoSlug: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: Error;  }> {
        const localVarPath = this.basePath + '/repositories/{username}/{repo_slug}/issues/{issue_id}/vote'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'issue_id' + '}', encodeURIComponent(String(issueId)))
            .replace('{' + 'repo_slug' + '}', encodeURIComponent(String(repoSlug)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdVotePut.');
        }

        // verify required parameter 'issueId' is not null or undefined
        if (issueId === null || issueId === undefined) {
            throw new Error('Required parameter issueId was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdVotePut.');
        }

        // verify required parameter 'repoSlug' is not null or undefined
        if (repoSlug === null || repoSlug === undefined) {
            throw new Error('Required parameter repoSlug was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdVotePut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.basic.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: Error;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Error");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            });
        });
    }
    /**
     * Stop watching this issue.
     * @param username This can either be the username or the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. An account is either a team or user. 
     * @param issueId The issue id
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    public async repositoriesUsernameRepoSlugIssuesIssueIdWatchDelete (username: string, issueId: string, repoSlug: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: Error;  }> {
        const localVarPath = this.basePath + '/repositories/{username}/{repo_slug}/issues/{issue_id}/watch'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'issue_id' + '}', encodeURIComponent(String(issueId)))
            .replace('{' + 'repo_slug' + '}', encodeURIComponent(String(repoSlug)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdWatchDelete.');
        }

        // verify required parameter 'issueId' is not null or undefined
        if (issueId === null || issueId === undefined) {
            throw new Error('Required parameter issueId was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdWatchDelete.');
        }

        // verify required parameter 'repoSlug' is not null or undefined
        if (repoSlug === null || repoSlug === undefined) {
            throw new Error('Required parameter repoSlug was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdWatchDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.basic.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: Error;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Error");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            });
        });
    }
    /**
     * Indicated whether or not the authenticated user is watching this issue.
     * @param username This can either be the username or the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. An account is either a team or user. 
     * @param issueId The issue id
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    public async repositoriesUsernameRepoSlugIssuesIssueIdWatchGet (username: string, issueId: string, repoSlug: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: Error;  }> {
        const localVarPath = this.basePath + '/repositories/{username}/{repo_slug}/issues/{issue_id}/watch'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'issue_id' + '}', encodeURIComponent(String(issueId)))
            .replace('{' + 'repo_slug' + '}', encodeURIComponent(String(repoSlug)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdWatchGet.');
        }

        // verify required parameter 'issueId' is not null or undefined
        if (issueId === null || issueId === undefined) {
            throw new Error('Required parameter issueId was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdWatchGet.');
        }

        // verify required parameter 'repoSlug' is not null or undefined
        if (repoSlug === null || repoSlug === undefined) {
            throw new Error('Required parameter repoSlug was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdWatchGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.basic.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: Error;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Error");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            });
        });
    }
    /**
     * Start watching this issue.  To start watching this issue, do an empty PUT. The 204 status code indicates that the operation was successful.
     * @param username This can either be the username or the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. An account is either a team or user. 
     * @param issueId The issue id
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    public async repositoriesUsernameRepoSlugIssuesIssueIdWatchPut (username: string, issueId: string, repoSlug: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: Error;  }> {
        const localVarPath = this.basePath + '/repositories/{username}/{repo_slug}/issues/{issue_id}/watch'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'issue_id' + '}', encodeURIComponent(String(issueId)))
            .replace('{' + 'repo_slug' + '}', encodeURIComponent(String(repoSlug)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdWatchPut.');
        }

        // verify required parameter 'issueId' is not null or undefined
        if (issueId === null || issueId === undefined) {
            throw new Error('Required parameter issueId was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdWatchPut.');
        }

        // verify required parameter 'repoSlug' is not null or undefined
        if (repoSlug === null || repoSlug === undefined) {
            throw new Error('Required parameter repoSlug was null or undefined when calling repositoriesUsernameRepoSlugIssuesIssueIdWatchPut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.basic.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: Error;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Error");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            });
        });
    }
    /**
     * Creates a new issue.  This call requires authentication. Private repositories or private issue trackers require the caller to authenticate with an account that has appropriate authorization.  The authenticated user is used for the issue\'s `reporter` field.
     * @param username This can either be the username or the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. An account is either a team or user. 
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     * @param body The new issue. The only required element is &#x60;title&#x60;. All other elements can be omitted from the body.
     */
    public async repositoriesUsernameRepoSlugIssuesPost (username: string, repoSlug: string, body: Issue, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: Issue;  }> {
        const localVarPath = this.basePath + '/repositories/{username}/{repo_slug}/issues'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'repo_slug' + '}', encodeURIComponent(String(repoSlug)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling repositoriesUsernameRepoSlugIssuesPost.');
        }

        // verify required parameter 'repoSlug' is not null or undefined
        if (repoSlug === null || repoSlug === undefined) {
            throw new Error('Required parameter repoSlug was null or undefined when calling repositoriesUsernameRepoSlugIssuesPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling repositoriesUsernameRepoSlugIssuesPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Issue")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.basic.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: Issue;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Issue");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the milestones that have been defined in the issue tracker.  This resource is only available on repositories that have the issue tracker enabled.
     * @param username This can either be the username or the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. An account is either a team or user. 
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    public async repositoriesUsernameRepoSlugMilestonesGet (username: string, repoSlug: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: PaginatedMilestones;  }> {
        const localVarPath = this.basePath + '/repositories/{username}/{repo_slug}/milestones'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'repo_slug' + '}', encodeURIComponent(String(repoSlug)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling repositoriesUsernameRepoSlugMilestonesGet.');
        }

        // verify required parameter 'repoSlug' is not null or undefined
        if (repoSlug === null || repoSlug === undefined) {
            throw new Error('Required parameter repoSlug was null or undefined when calling repositoriesUsernameRepoSlugMilestonesGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.basic.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: PaginatedMilestones;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "PaginatedMilestones");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the specified issue tracker milestone object.
     * @param username This can either be the username or the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. An account is either a team or user. 
     * @param milestoneId The milestone\&#39;s id
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    public async repositoriesUsernameRepoSlugMilestonesMilestoneIdGet (username: string, milestoneId: number, repoSlug: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: Milestone;  }> {
        const localVarPath = this.basePath + '/repositories/{username}/{repo_slug}/milestones/{milestone_id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'milestone_id' + '}', encodeURIComponent(String(milestoneId)))
            .replace('{' + 'repo_slug' + '}', encodeURIComponent(String(repoSlug)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling repositoriesUsernameRepoSlugMilestonesMilestoneIdGet.');
        }

        // verify required parameter 'milestoneId' is not null or undefined
        if (milestoneId === null || milestoneId === undefined) {
            throw new Error('Required parameter milestoneId was null or undefined when calling repositoriesUsernameRepoSlugMilestonesMilestoneIdGet.');
        }

        // verify required parameter 'repoSlug' is not null or undefined
        if (repoSlug === null || repoSlug === undefined) {
            throw new Error('Required parameter repoSlug was null or undefined when calling repositoriesUsernameRepoSlugMilestonesMilestoneIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.basic.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: Milestone;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Milestone");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the versions that have been defined in the issue tracker.  This resource is only available on repositories that have the issue tracker enabled.
     * @param username This can either be the username or the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. An account is either a team or user. 
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    public async repositoriesUsernameRepoSlugVersionsGet (username: string, repoSlug: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: PaginatedVersions;  }> {
        const localVarPath = this.basePath + '/repositories/{username}/{repo_slug}/versions'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'repo_slug' + '}', encodeURIComponent(String(repoSlug)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling repositoriesUsernameRepoSlugVersionsGet.');
        }

        // verify required parameter 'repoSlug' is not null or undefined
        if (repoSlug === null || repoSlug === undefined) {
            throw new Error('Required parameter repoSlug was null or undefined when calling repositoriesUsernameRepoSlugVersionsGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.basic.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: PaginatedVersions;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "PaginatedVersions");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            });
        });
    }
    /**
     * Returns the specified issue tracker version object.
     * @param username This can either be the username or the UUID of the account, surrounded by curly-braces, for example: &#x60;{account UUID}&#x60;. An account is either a team or user. 
     * @param versionId The version\&#39;s id
     * @param repoSlug This can either be the repository slug or the UUID of the repository, surrounded by curly-braces, for example: &#x60;{repository UUID}&#x60;. 
     */
    public async repositoriesUsernameRepoSlugVersionsVersionIdGet (username: string, versionId: number, repoSlug: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: Version;  }> {
        const localVarPath = this.basePath + '/repositories/{username}/{repo_slug}/versions/{version_id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'version_id' + '}', encodeURIComponent(String(versionId)))
            .replace('{' + 'repo_slug' + '}', encodeURIComponent(String(repoSlug)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling repositoriesUsernameRepoSlugVersionsVersionIdGet.');
        }

        // verify required parameter 'versionId' is not null or undefined
        if (versionId === null || versionId === undefined) {
            throw new Error('Required parameter versionId was null or undefined when calling repositoriesUsernameRepoSlugVersionsVersionIdGet.');
        }

        // verify required parameter 'repoSlug' is not null or undefined
        if (repoSlug === null || repoSlug === undefined) {
            throw new Error('Required parameter repoSlug was null or undefined when calling repositoriesUsernameRepoSlugVersionsVersionIdGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.api_key.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.basic.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.oauth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: Version;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Version");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            });
        });
    }
}
