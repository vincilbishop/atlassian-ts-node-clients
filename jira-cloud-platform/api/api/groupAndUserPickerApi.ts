/**
 * The Jira Cloud platform REST API
 * Jira Cloud platform REST API documentation
 *
 * The version of the OpenAPI document: 1001.0.0-SNAPSHOT
 * Contact: ecosystem@atlassian.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');

/* tslint:disable:no-unused-locals */
import { FoundUsersAndGroups } from '../model/foundUsersAndGroups';

import { ObjectSerializer, Authentication, VoidAuth } from '../model/models';
import { OAuth } from '../model/models';

let defaultBasePath = 'http://localhost';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum GroupAndUserPickerApiApiKeys {
}

export class GroupAndUserPickerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: GroupAndUserPickerApiApiKeys, value: string) {
        (this.authentications as any)[GroupAndUserPickerApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }

    /**
     * Returns a list of users and groups matching a string. The string is used:   *  for users, to find a case-insensitive match with display name and e-mail address. Note that if a user has hidden their email address in their user profile, partial matches of the email address will not find the user. An exact match is required.  *  for groups, to find a case-sensitive match with group name.  For example, if the string *tin* is used, records with the display name *Tina*, email address *sarah@tinplatetraining.com*, and the group *accounting* would be returned.  Optionally, the search can be refined to:   *  the projects and issue types associated with a custom field, such as a user picker. The search can then be further refined to return only users and groups that have permission to view specific:           *  projects.      *  issue types.          If multiple projects or issue types are specified, they must be a subset of those enabled for the custom field or no results are returned. For example, if a field is enabled for projects A, B, and C then the search could be limited to projects B and C. However, if the search is limited to projects B and D, nothing is returned.  *  not return Connect app users and groups.  *  return groups that have a case-insensitive match with the query.  The primary use case for this resource is to populate a picker field suggestion list with users or groups. To this end, the returned object includes an `html` field for each list. This field highlights the matched query term in the item name with the HTML strong tag. Also, each list is wrapped in a response object that contains a header for use in a picker, specifically *Showing X of Y matching groups*.  This operation can be accessed anonymously if permissions allow open access.  **[Permissions](#permissions) required:** *Browse users and groups* [global permission](https://confluence.atlassian.com/x/yodKLg).
     * @summary Find users and groups
     * @param query The search string.
     * @param maxResults The maximum number of items to return in each list. The maximum is &#x60;1000&#x60;.
     * @param showAvatar Indicates whether the user avatar should be returned. If an invalid value is provided, the default value is used.
     * @param fieldId The custom field ID of the field this request is for.
     * @param projectId The ID of a project that returned users and groups must have permission to view. To include multiple projects, provide multiple copies of this parameter. For example, &#x60;projectId&#x3D;10000&amp;projectId&#x3D;10001&#x60;. This parameter is only used when &#x60;fieldId&#x60; is present.
     * @param issueTypeId The ID of an issue type that returned users and groups must have permission to view. To include multiple issue types, provide multiple copies of this parameter. For example, &#x60;issueTypeId&#x3D;10000&amp;issueTypeId&#x3D;10001&#x60;. Special values, such as &#x60;-1&#x60; (all standard issue types) and &#x60;-2&#x60; (all subtask issue types), are supported. This parameter is only used when &#x60;fieldId&#x60; is present.
     * @param avatarSize The size of the avatar to return. If an invalid value is provided, the default value is used.
     * @param caseInsensitive Indicates whether the search for groups should be case insensitive.
     * @param excludeConnectAddons Indicates whether Connect app users and groups should be excluded from the search results. If an invalid value is provided, the default value is used.
     */
    public async comAtlassianJiraRestV2IssueGroupAndUserPickerResourceFindUsersAndGroupsGet (query: string, maxResults?: number, showAvatar?: boolean, fieldId?: string, projectId?: Array<string>, issueTypeId?: Array<string>, avatarSize?: 'xsmall' | 'xsmall@2x' | 'xsmall@3x' | 'small' | 'small@2x' | 'small@3x' | 'medium' | 'medium@2x' | 'medium@3x' | 'large' | 'large@2x' | 'large@3x' | 'xlarge' | 'xlarge@2x' | 'xlarge@3x' | 'xxlarge' | 'xxlarge@2x' | 'xxlarge@3x' | 'xxxlarge' | 'xxxlarge@2x' | 'xxxlarge@3x', caseInsensitive?: boolean, excludeConnectAddons?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.ClientResponse; body: FoundUsersAndGroups;  }> {
        const localVarPath = this.basePath + '/rest/api/2/groupuserpicker';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'query' is not null or undefined
        if (query === null || query === undefined) {
            throw new Error('Required parameter query was null or undefined when calling comAtlassianJiraRestV2IssueGroupAndUserPickerResourceFindUsersAndGroupsGet.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (maxResults !== undefined) {
            localVarQueryParameters['maxResults'] = ObjectSerializer.serialize(maxResults, "number");
        }

        if (showAvatar !== undefined) {
            localVarQueryParameters['showAvatar'] = ObjectSerializer.serialize(showAvatar, "boolean");
        }

        if (fieldId !== undefined) {
            localVarQueryParameters['fieldId'] = ObjectSerializer.serialize(fieldId, "string");
        }

        if (projectId !== undefined) {
            localVarQueryParameters['projectId'] = ObjectSerializer.serialize(projectId, "Array<string>");
        }

        if (issueTypeId !== undefined) {
            localVarQueryParameters['issueTypeId'] = ObjectSerializer.serialize(issueTypeId, "Array<string>");
        }

        if (avatarSize !== undefined) {
            localVarQueryParameters['avatarSize'] = ObjectSerializer.serialize(avatarSize, "'xsmall' | 'xsmall@2x' | 'xsmall@3x' | 'small' | 'small@2x' | 'small@3x' | 'medium' | 'medium@2x' | 'medium@3x' | 'large' | 'large@2x' | 'large@3x' | 'xlarge' | 'xlarge@2x' | 'xlarge@3x' | 'xxlarge' | 'xxlarge@2x' | 'xxlarge@3x' | 'xxxlarge' | 'xxxlarge@2x' | 'xxxlarge@3x'");
        }

        if (caseInsensitive !== undefined) {
            localVarQueryParameters['caseInsensitive'] = ObjectSerializer.serialize(caseInsensitive, "boolean");
        }

        if (excludeConnectAddons !== undefined) {
            localVarQueryParameters['excludeConnectAddons'] = ObjectSerializer.serialize(excludeConnectAddons, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.ClientResponse; body: FoundUsersAndGroups;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "FoundUsersAndGroups");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            });
        });
    }
}
